#include "INIFile.h"

INIFile::INIFile(std::string path)
{
	std::ifstream fin;
	fin.open(path, std::ios::in);
	if (open(fin)) {
		_path = path;
	}
}

bool INIFile::save_to_file(std::string path) const
{
	std::ofstream fout;
	fout.open(path, std::ios::out);
	bool flag = write(fout);
	fout.close();
	return flag;
}

std::map<std::string, INIFile::INISection>& INIFile::get_map()
{
	return _data;
}

INIFile::INISection& INIFile::operator[](std::string section)
{
	return _data[section];
}

bool INIFile::open(std::ifstream& fin)
{
	if (!fin.is_open())
		return false;
	bool flag = false;
	flag = parse(fin);
	fin.close();
	return flag;
}

bool INIFile::parse(std::ifstream& fin)
{
	auto trim_string = [](std::string& str)
	{
		size_t commit_flag = str.find(';');
		if (commit_flag != str.npos)
			str = str.substr(0, commit_flag);
		if (!str.empty())
		{
			size_t first_not_space = str.find_first_not_of(' ');
			size_t last_not_space = str.find_last_not_of(' ');
			if (first_not_space != str.npos && last_not_space != str.npos && last_not_space - first_not_space > 0)
			{
				str = str.substr
				(
					first_not_space,
					last_not_space - first_not_space + 1
				);
			}
			else
				str.resize(0);
		}
	};

	enum parsing_stage {
		finding_section,
		parsing_section,
		parsing_exit
	};

	parsing_stage parsing_state = finding_section;
	std::string section_name;

	std::string line_buffer;
	while (!fin.eof())
	{
		if (parsing_state != parsing_exit)
		{
			std::getline(fin, line_buffer);
			trim_string(line_buffer);
		}
		
		if (parsing_state == parsing_exit)
			parsing_state = finding_section;

		if (line_buffer.empty())
			continue;

		if (parsing_state == finding_section)
		{
			if (line_buffer[0] == '[')
			{
				size_t back_bracket = line_buffer.find_first_of(']');
				if (back_bracket == line_buffer.npos || back_bracket == 1)
					continue;
				section_name = line_buffer.substr(1, back_bracket - 1);
				parsing_state = parsing_section;
				continue;
			}
		}
		else
		{
			if (line_buffer.find('[') != line_buffer.npos)
			{
				parsing_state = parsing_exit;
				continue;
			}

			size_t equal_flag = line_buffer.find_first_of('=');
			if (equal_flag == line_buffer.npos)
				continue;
			std::string pair_key = line_buffer.substr(0, equal_flag);
			std::string pair_value = line_buffer.substr(equal_flag + 1);
			_data[section_name][pair_key] = pair_value;
		}
	}

	return true;
}

bool INIFile::write(std::ofstream& fout) const
{
	if (!fout.is_open())
		return false;

	fout << "; This INI File is generated by CSFEditorSample! \n\n";
	for (auto& section : _data)
	{
		fout << '[' << section.first << "]\n";
		for (auto& key : section.second)
			fout << key.first << '=' << key.second << '\n';
		fout << '\n';
	}
	fout.flush();
	return true;
}